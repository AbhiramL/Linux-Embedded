Device Driver Programming: LED, UART, I2C device

--Buildroot setup--

Follow the following instruction with buildroot after running make beaglebone_defconfig
Enable the following:

Buildroot: make menuconfig
Toolchain:
-c++ support
-toolchain to use glibc, gcc 13.x, binutils 2.40 or higher
-enable c++ support

Kernel
-Linux kernel tools: enable gpio tools
-target packages>filesystem and flash utilities>e2fsprogs & enable dofstools (all options) dofstools needs glibc toolchain not musl

System Configuration:
-Enable /dev management: Dyanamic using detmpfs + mdev
-Enable remount root filesystem read-write during boot

Target Packages:
-System Tools: enable kmod and kmod util
- "      "   : enable util-linux>mount/umount

File system:
-enable tar rootfs 
-enable ext4 filesystem
-512M exact size

Busybox: make busybox-menuconfig
Linux Module Utilities:
-insmod, rmmod, lsmod, modinfo, modprobe must be enabled

Linux: make linux-menuconfig
-enable loadable module support

Uboot: make uboot-menuconfig
-Enable: Environment>Environment is in a MMC device, Env is in a Fat Fs
-Load value 'mmc' for: Environment>Name of block device for Environment
-Load value '1:1' for:      "     >Dev and part for where to store the environment in FAT
-Change Environment>mmc device number and mmc partition number to '1'

end.

--Setting up DTS file and module environment--

1. Edit .dts file located at buildroot/output/build/linux-custom/arch/arm/boot/dts/am335x-boneblack.dts
    - linux-custom is the folder for the buildroot linux version since I enabled custom tarball in menuconfig. If 
    you make buildroot to make the 6.6 kernel in the image for example, find the linux-6.6 folder.

2. Navigate to the /buildroot/output/build/linux-custom folder where the kernel source files are. 
    - Run 'make dtbs' to make the linux kernel compile the dts files into dtb files.

3. Create a directory in the home directory '~' for your modules, something like kernMods/moduleName

4. If permission errors occur in tmp directories when you are compiling, do:

sudo chown -R $USER:$USER /home/abhiram/kernMods/moduleFolderName
chmod -R u+rwX /home/abhiram/kernMods/moduleFolderName

5. The code in the kernel directories of the github are for kernel 6.6.32, certain code may not be compatible with earlier kernels.


--Developing Hello module--

1. Follow structure of helloMod.c in modules folder on Github

2. Make a Makefile to use buildroot's generated cross compiler toolchain by specifying CROSS_COMPILE in the terminal environment and link the buildroot generated linux 
image's kernel headers by specifying KERNEL_DIR and updating the PATH variable.

export PATH=$HOME/buildroot-2024.11.1/output/host/bin:$PATH     <--change buildroot version if needed
export ARCH=arm
export CROSS_COMPILE=arm-buildroot-linux-gnueabihf-

Note: if changes are made to buildroot's toolchain or kernel version settings, these values will change. linux-custom in the Makefile refers to the custom tarball 
of the linux kernel buildroot will build.

3. Boot into linux image on BBB, use 'insmod mod.ko' to load the module and 'rmmod mod' to unload the mod. Use lsmod to check loaded modules.


--Developing Led_blink mod--

1. The first thing to do is to enable a legacy interface for busybox by enabling CONFIG_GPIO_SYSFS in the kernel configuration .config file. Also make sure 
Debugfs is enabled (CONFIG_DEBUG_FS and CONFIG_DEBUG_FS_ALLOW_ALL).

Note: 
You can modify onboard LED to test the legacy interface:
In the BBB, do the following:

cd /sys/class/leds
ls                  <-- these are on-board LEDS close to the physical mini usb-A port

Pick one: cd beaglebone:green:usr0/

cat trigger

As you can see, there are many triggers to choose from. You can disable all triggers by:

echo none > trigger

And then directly control the LED:

echo 1 > brightness
echo 0 > brightness

You could also use the timer trigger to light the LED with specified time on and time off:

echo timer > trigger
echo 10 > delay_on
echo 200 > delay_off

2. The pinout for the Beaglebone black has expansion headers P8 and P9, we will access P9_12 or GPIO1_28 as stated in the BBB system reference manual. 
Use the following equation to get the Linux GPIO number:

    Linux GPIO Number = (GPIO bank number * 32) + pin number in the bank

so for GPIO1_28 -->   L = (1 * 32) + 28 = 60, so GPIO 60 is to be referenced in the kernel mod to drive P9_12

Note:
In my testing, GPIO 60 was not 'available' as I got an error: 
LED Blink Module: GPIO 60 request failed
insmod: ERROR: could not insert module led_blink.ko: Unknown error 517

-By running the command 'cat /sys/kernel/debug/gpio' in the BBB terminal after the kernel has booted, 
you will see the state of all gpio pins on the system.
-if the gpio pin number you set didnt show up here, it means it is likely in use and cannot be used.
-Run the cat command above, find the pin you want to use to drive a LED
available ones will look like : gpio-540 (P9_12               |sysfs               ) in  hi 

TLDR. 540 is the pin number used in this gpio bank and not 60 as I calculated earlier.

3. Set the led pin number in the .c file, and run the compiled .ko using insmod and rmmod. My LED module is to be used as follows:
-on the breadboard, connect the ground of the BBB to the gnd of the breadboard
-connect the pin you allocated to toggling to the available rows A-J on the breadboard and, in series, connect an LED to it and the ground of the breadboard.

Remember to do the following when running make to compile the led_blink.c:
export PATH=$HOME/buildroot-2024.11.1/output/host/bin:$PATH     <--change buildroot version if needed
export ARCH=arm
export CROSS_COMPILE=arm-buildroot-linux-gnueabihf-


--UART Module--

Before starting to program the module, keep in mind a userspace program will drive the driver/kernel module:

Developing a Kernel module for operation of the UART port:

-Develop a simple kernel module with functions that can be mapped to libc system calls:
Open - which can be mapped to initialization of the UART port
Read - which can be mapped to reading characters on serial line into a buffer
Write - which can be mapped to writing characters to the serial line from a buffer
Ioctl - which can be mapped to setting baud rate and parity etc.

-Register the character device so a new device will appear under /dev/ in the linux directory by simply creating a character device within the kernel module 
via register_chrdev. Unregister the device at the end of the module(when it is to be unloaded/removed using rmmod) with unregister_chrdev.

-Create a file operations struct that the linux kernel can use to map system calls with module functions that you define. At least the 4 above system calls 
should be mapped to kernel module functions. 

-The userspace program will call open, read, write, ioctl, which will invoke the kernel to do sys_open, sys_read, sys_write, and sys_ioctl. When these sys 
calls are executed by the kernel, the file operations struct within the kernel module will direct the kernel to execute the associated function then return.




 


